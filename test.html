<!doctype html>
<html>
<head>
<meta charset="utf-8">
<style>
html, body, main { margin: 0; padding: 0; box-sizing: border-box; }
body {
    background: linear-gradient(to right, black, white);
}
main {
    width: 100vw;
    height: 100vh;
    transition: opacity 100ms ease-out;
}
main > svg {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    position: absolute;
}
button {
    background: transparent;
    border-width: 0;
    color: black;
    position: absolute;
    display: none;
    filter: drop-shadow(0px 0px 2px #fff);
    background: transparent;
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-size: 2vw;
}
#inventory {
    position: absolute;
    background: black;
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}
#inventory ul {
    margin: 0;
    padding: 0;
    list-style: none;
}
#inventory ul li {
    margin: 0;
    padding: 0;
    background: radial-gradient(closest-side, white, black);
    width: 100%;
    height: 0;
    padding-bottom: 100%;
    position: relative;
}
#inventory ul li[data-using="yes"] {
    background: radial-gradient(closest-side, yellow, black);
}
#inventory ul li svg {
    width: 90%;
    height: 90%;
    position: absolute;
    top: 5%;
    left: 5%;
}
#draweropen1, #draweropen2, #draweropen3, #draweropen4 {
    transition: transform 200ms ease-in-out;
}
#flame {
    animation: flicker 220ms infinite alternate, judder 480ms infinite alternate;
    transform-origin: 70% 20%;
}
@keyframes flicker { 0% { opacity: 0.7; } 100% { opacity: 1; } }
@keyframes judder {
    0% { transform: scaleY(0.95) } 
    100% { transform: scaleY(1.05) }
}

.chosen-coin ellipse:nth-of-type(2) {
    fill: rgba(0, 255, 0, 0.4) !important;
}
ellipse.available-slot {
    fill: rgba(0, 255, 0, 0.4) !important;
}

</style>
</head>
<body>
<main></main>
<button id="up">▲</button>
<button id="right">▸</button>
<button id="down">▼</button>
<button id="left">◂</button>
<audio src="166184__drminky__retro-coin-collect.wav" id="collect"></audio>
<audio src="484266__inspectorj__party-pack-match-ignite-01-01.wav" id="ignite"></audio>
<audio src="360949__marcusgar__drawer.wav" id="drawer"></audio>
<audio src="398396__caitlin-100__knife-scrape.mp3" id="tileremove"></audio>
<audio src="468414__atg65__power-failure.wav" id="coinfail"></audio>
<audio src="Lightless%20Dawn.mp3" loop id="bgm"></audio>
<div id="inventory">
    <ul>
    </ul>
</div>
<script>
const unhidden = new Set();
const nowhidden = new Set();
let coin_move_count = 0;
const handlers = {
    coin_click: el => {
        // if we don't have slots set up for coins, set them up
        if (!document.querySelector("[data-coin-slot]")) {
            document.getElementById("coin1").dataset.coinSlot = "4_3";
            document.getElementById("coin2").dataset.coinSlot = "3_3";
            document.getElementById("coin3").dataset.coinSlot = "3_4";
            document.getElementById("coin4").dataset.coinSlot = "2_2";
            document.getElementById("coin5").dataset.coinSlot = "2_3";
            document.getElementById("coin6").dataset.coinSlot = "2_4";
            coin_move_count = 0;
        }
        let existing = document.querySelector(".chosen-coin");
        if (existing) existing.classList.remove("chosen-coin");
        let existing_slots = document.querySelectorAll(".available-slot");
        if (existing_slots.length > 0) Array.from(existing_slots).map(es => {
            es.classList.remove("available-slot");
        });
        if (existing == el) { return; }
        el.classList.add("chosen-coin");
        // and calculate available slots
        let coins_in = Array.from(document.querySelectorAll("[data-coin-slot]")).map(cel => {
            return cel.dataset.coinSlot.split("_").map(v => parseInt(v, 10));
        })
        let two_coin_slots = {};
        let add = (x, y) => {
            if (!two_coin_slots[[y,x]]) two_coin_slots[[y,x]] = 0;
            two_coin_slots[[y,x]] += 1;
        }
        coins_in.forEach(([y, x]) => {
            if (el.dataset.coinSlot == y + "_" + x) return; // can't count us as part of the 2 coins!
            add(x-1, y); add(x+1, y);
            if (y%2 == 1) {
                // odd row
                add(x-1, y-1); add(x, y-1); add(x-1, y+1); add(x, y+1);
            } else {
                // even row
                add(x, y-1); add(x+1, y-1); add(x, y+1); add(x+1, y+1);
            }
        })
        for (let k in two_coin_slots) {
            if (two_coin_slots[k] >= 2) {
                let slot = document.getElementById("coin_slot_" + k.replace(",", "_"));
                if (slot) {
                    slot.classList.add("available-slot");
                }
            }
        }
    },
    coin_slot_click: el => {
        if (coin_move_count == 4) return;
        if (!el.classList.contains("available-slot")) return;
        let cc = document.querySelector(".chosen-coin");
        if (!cc) return;
        let fromSlot = document.getElementById("coin_slot_" + cc.dataset.coinSlot);
        let fromBB = fromSlot.getBBox();
        let toBB = el.getBBox();
        let xdiff = toBB.x - fromBB.x;
        let ydiff = toBB.y - fromBB.y;
        let trans = cc.getAttribute("transform");
        let parts = trans.replace("matrix(", "").replace(")", "").split(",");
        parts[4] = (parseFloat(parts[4]) + xdiff).toString();
        parts[5] = (parseFloat(parts[5]) + ydiff).toString();
        cc.setAttribute("transform", "matrix(" + parts.join(",") + ")");
        cc.classList.remove("chosen-coin");
        cc.dataset.coinSlot = el.id.replace("coin_slot_", "");
        let existing_slots = document.querySelectorAll(".available-slot");
        if (existing_slots.length > 0) Array.from(existing_slots).map(es => {
            es.classList.remove("available-slot");
        });
        coin_move_count += 1;
        document.getElementById("coin_move_" + coin_move_count).style.display = "none";
        if (coin_move_count == 4) {
            let coins_in = Array.from(document.querySelectorAll("[data-coin-slot]")).map(cel => {
                return cel.dataset.coinSlot.split("_").map(v => parseInt(v, 10));
            })
            let my = Math.min.apply(null, coins_in.map(a => a[0]));
            let mx = Math.min.apply(null, coins_in.map(a => a[1]));
            coins_in = coins_in.map(([y, x]) => [y-my, x-mx]);
            coins_in.sort((a, b) => {
                if (a[0] == b[0]) return a[1] - b[1];
                return a[0] - b[0];
            });
            let result = coins_in.map(([y, x]) => y + "" + x).join("");
            if (result == "010210122122" || result == "000110122021") {
                console.log("ok!");
                return;
            } else {
                console.log(result);
            }

            document.getElementById("coinfail").play();
            setTimeout(() => {
                coin_move_count = 0;
                load("coins");
            }, 1000);
        }
    },
    drawer_slide: el => {
        if (!el.dataset.open) {
            el.style.transform = "translateY(16%)";
            el.dataset.open = "yes";
        } else {
            el.style.transform = "";
            el.dataset.open = "";
        }
        document.getElementById("drawer").play();
    },
    start_music: el => {
        document.getElementById("bgm").play();
    },
    take: async el => {
        /* remember to remove the desc from the SVGs for individual items, or they're takeable
           when they're in inventory */
        taken.push({scene: currentRoom, obj: el.getAttribute("id")});
        el.remove();
        document.getElementById("collect").play();
        let li = document.createElement("li");
        let response = await fetch(el.id + ".svg");
        li.innerHTML = await response.text();
        li.dataset.using = "no";
        li.dataset.item = el.id;
        li.onclick = function() {
            if (li.dataset.using == "no") {
                let existing = document.querySelector('li[data-using="yes"]');
                if (existing) { existing.dataset.using = "no"; }
                let invsvg = li.querySelector("svg");
                let crs = invsvg.cloneNode(true);
                let bb = invsvg.getBoundingClientRect();
                crs.setAttribute("width", bb.width);
                crs.setAttribute("height", bb.width);
                [_, _, vbw, vbh] = crs.getAttribute('viewBox').split(" ");
                let pointer = document.createElementNS("http://www.w3.org/2000/svg", "path");
                pointer.setAttribute("d", "M0,0 L" + (vbw / 8) + ",0 L0," + (vbw / 8) + "Z");
                pointer.setAttribute("fill", "red")
                crs.appendChild(pointer);
                let dataurl = "data:image/svg+xml;base64," + btoa(crs.outerHTML);
                document.body.style.cursor = "url(" + dataurl + "), auto";
                li.dataset.using = "yes";
            } else {
                document.body.style.cursor = "auto";
                li.dataset.using = "no";
            }
        }
        document.querySelector("#inventory ul").appendChild(li);
    },
    use: (nail, hammer) => { // these are IDs, not elements
        console.log("using", hammer, "on", nail);
        if (nail == "candle" && hammer == "matches") {
            document.getElementById("flame").style.display = "block";
            document.getElementById("glow").style.display = "block";
            document.getElementById("secretmessage").style.display = "block";
            unhidden.add("flame");
            unhidden.add("glow");
            unhidden.add("secretmessage");
            document.getElementById("ignite").play();
        } else if (nail == "tiles" && hammer == "knife") {
            document.getElementById("tileholes").style.display = "block";
            unhidden.add("tileholes");
            document.getElementById("tiles").style.display = "none";
            nowhidden.add("tiles");
            document.getElementById("tileremove").play();
        }
    }
}
let currentRoom;
const taken = [];
const buttons = new Set(["down", "up", "left", "right"]);
function hookup() {
    let buttons_found = new Set();
    let aside = document.querySelector("aside");
    Array.from(document.querySelectorAll("svg desc")).forEach(el => {
        let p = el.parentNode;
        let clickrect;
        el.textContent.split("\n").forEach(line => {
            let parts = line.trim().split(":");
            if (parts.length == 2) {
                if (parts[0] == "click" || parts[0] == "use") {
                    let fn;
                    if (parts[0] == "use") {
                        fn = (e) => {
                            // note: you must define use handlers before click handlers in the description!
                            // otherwise the click handler will be defined before the use handler, and so
                            // the use handler's stopImmediatePropagation will be useless
                            let existing = document.querySelector('li[data-using="yes"]');
                            if (existing) {
                                if (parts[1] == existing.dataset.item) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    e.stopImmediatePropagation();
                                    handlers.use(p.id, parts[1]);
                                }
                            }
                        }
                    } else if (handlers[parts[1]]) {
                        fn = (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            handlers[parts[1]](p);
                        }
                    } else {
                        fn = () => {
                            load(parts[1]);
                        }
                    }
                    let vbbg = p.getBBox();
                    let rect;
                    if (clickrect) {
                        rect = clickrect;
                    } else {
                        rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                        rect.setAttribute("x", vbbg.x)
                        rect.setAttribute("y", vbbg.y)
                        rect.setAttribute("width", vbbg.width)
                        rect.setAttribute("height", vbbg.height)
                        rect.setAttribute("fill", "transparent")
                        rect.setAttribute("data-clickrect", "clickrect");
                        rect.dataset.clickable = "clickable";
                        if (p.nodeName != "g") {
                            // putting the clickrect inside another element is likely to
                            // not work because the other element will eat all our clicks
                            // so put it in the parent of the parentNode, and make sure it's
                            // at the end, so definitely after the actual element and therefore
                            // on top of it
                            p.parentNode.appendChild(rect);
                        } else {
                            p.insertBefore(rect, p.firstChild);
                        }
                        clickrect = rect;
                    }
                    rect.addEventListener("click", fn, false);
                } else if (buttons.has(parts[0])) {
                    buttons_found.add(parts[0]);
                    document.getElementById(parts[0]).dataset.goto = parts[1];
                }
            } else if (parts.length == 1) {
                if (parts[0] == "takeable") {
                    fn = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        handlers.take(p);
                    }
                    let vbbg = p.getBBox();
                    let rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    rect.setAttribute("x", vbbg.x)
                    rect.setAttribute("y", vbbg.y)
                    rect.setAttribute("width", vbbg.width)
                    rect.setAttribute("height", vbbg.height)
                    rect.setAttribute("fill", "transparent")
                    p.insertBefore(rect, p.firstChild);
                    rect.onclick = fn;
                    rect.dataset.clickable = "clickable";
                } else if (parts[0] == "hidden" && !unhidden.has(p.id)) {
                    p.style.display = "none";
                }
            }
        })
    })
    buttons.forEach(bname => {
        if (buttons_found.has(bname)) {
            document.getElementById(bname).style.display = "block";
        } else {
            document.getElementById(bname).style.display = "none";
        }
    })
    // and make all not-explicitly-clickable leaf elements unclickable
    Array.from(document.querySelectorAll("svg *")).forEach(el => {
        if (!el.dataset.clickable && el.childNodes.length === 0) {
            el.style.pointerEvents = "none";
        }
    })
    // and remove all already-taken items that aren't in inventory
    taken.filter(item => item.scene == currentRoom).map(
        item => { 
            let obj = document.getElementById(item.obj);
            if (!obj.closest("#inventory")) {
                obj.remove();
            }
        })
    // and remove all now hidden items
    Array.from(nowhidden).map(
        item => { 
            let obj = document.getElementById(item);
            if (obj) obj.remove();
        })
    // and show main (it was made invisible so that we don't see hidden stuff briefly appear)
    document.querySelector("main").style.opacity = "1";
}
function resize() {
    // size the svg
    let svg = document.querySelector("main > svg");
    let war = window.innerWidth / window.innerHeight;
    let sar = 800 / 600;
    let t, l, w, h;
    if (war > sar) {
        h = window.innerHeight;
        w = h * sar;
        t = 0;
        l = (window.innerWidth - w) / 2;
    } else {
        w = window.innerWidth;
        h = w / sar;
        l = 0;
        t = (window.innerHeight - h) / 2;
    }
    svg.style.height = h + "px";
    svg.style.width = w + "px";
    svg.style.top = t + "px";
    svg.style.left = l + "px";
    // move inventory
    let inv = document.querySelector("#inventory");
    let iw = w / 8;
    inv.style.width = iw + "px";
    inv.style.left = (l + w - iw) + "px";
    inv.style.top = t + "px";
    inv.style.height = h + "px";
    // and move the buttons
    let up = document.querySelector("#up");
    let right = document.querySelector("#right");
    let down = document.querySelector("#down");
    let left = document.querySelector("#left");
    let bh = h / 20; let bw = w / 20;
    up.style.top = t + "px"; up.style.left = l + "px";
    up.style.width = (w - iw) + "px"; up.style.height = bh + "px";
    left.style.top = t + "px"; left.style.left = l + "px";
    left.style.width = bw + "px"; left.style.height = h + "px";
    down.style.top = (t + h - bh) + "px"; down.style.left = l + "px";
    down.style.width = (w - iw) + "px"; down.style.height = bh + "px";
    right.style.top = t + "px"; right.style.left = (l + w - bw - iw) + "px";
    right.style.width = bw + "px"; right.style.height = h + "px";
}
async function load(r) {
    Array.from(document.querySelectorAll("aside div")).forEach(d => { d.remove() });
    let response = await fetch(r + ".svg");
    document.querySelector("main").style.opacity = "0";
    setTimeout(async () => {
        document.querySelector("main").innerHTML = await response.text();
        currentRoom = r;
        resize();
        setTimeout(hookup, 0);
    }, 100);
}
buttons.forEach(bname => {
    let b = document.getElementById(bname);
    b.onclick = () => {
        load(b.dataset.goto); 
    }
});
load("title");
window.onresize = resize;
</script>
</body>
</html>