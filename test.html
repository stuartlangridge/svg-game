<!doctype html>
<html>
<head>
<meta charset="utf-8">
<link href="https://fonts.googleapis.com/css?family=Nanum+Brush+Script&display=swap" rel="stylesheet">
<style>
html, body, main { margin: 0; padding: 0; box-sizing: border-box; }
body {
    background: linear-gradient(to right, black, white);
}
main {
    width: 100vw;
    height: 100vh;
    transition: opacity 100ms ease-out;
}
main > svg {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    position: absolute;
}
button {
    background: transparent;
    border-width: 0;
    color: black;
    position: absolute;
    display: none;
    filter: drop-shadow(0px 0px 2px #fff);
    background: transparent;
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-size: 2vw;
}
#inventory {
    position: absolute;
    background: black;
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}
#inventory ul {
    margin: 0;
    padding: 0;
    list-style: none;
}
#inventory ul li {
    margin: 0;
    padding: 0;
    background: radial-gradient(closest-side, white, black);
    width: 100%;
    height: 0;
    padding-bottom: 100%;
    position: relative;
}
#inventory ul li[data-using="yes"] {
    background: radial-gradient(closest-side, yellow, black);
}
#inventory ul li svg {
    width: 90%;
    height: 90%;
    position: absolute;
    top: 5%;
    left: 5%;
}
#draweropen1, #draweropen2, #draweropen3, #draweropen4 {
    transition: transform 200ms ease-in-out;
}
#flame {
    animation: flicker 220ms infinite alternate, judder 480ms infinite alternate;
    transform-origin: 70% 20%;
}
@keyframes flicker { 0% { opacity: 0.7; } 100% { opacity: 1; } }
@keyframes judder {
    0% { transform: scaleY(0.95) } 
    100% { transform: scaleY(1.05) }
}

.chosen-coin ellipse:nth-of-type(2) {
    fill: rgba(0, 255, 0, 0.4) !important;
}
ellipse.available-slot {
    fill: rgba(0, 255, 0, 0.4) !important;
}
aside#error {
    position: absolute;
    background: black;
    color: white;
    font-family: 'Nanum Brush Script', cursive;
    border-radius: 20px;
    font-size: 3vw;
    padding: 0.2vw 1vw;
    pointer-events: none;
    opacity: 0;
    transition: opacity 250ms ease-in-out;
}
aside#taken {
    position: absolute;
    background: black;
    color: white;
    font-family: 'Nanum Brush Script', cursive;
    border-radius: 20px;
    font-size: 3vw;
    padding: 0.2vw 1vw;
    pointer-events: none;
    opacity: 0;
    transition: opacity 250ms ease-in-out;
}
[data-clickrect] {
    stroke-width: 0 !important;
}
</style>
</head>
<body>
<main></main>
<button id="up">▲</button>
<button id="right">▸</button>
<button id="down">▼</button>
<button id="left">◂</button>
<audio src="166184__drminky__retro-coin-collect.wav" id="collect"></audio>
<audio src="484266__inspectorj__party-pack-match-ignite-01-01.wav" id="ignite"></audio>
<audio src="360949__marcusgar__drawer.wav" id="drawer"></audio>
<audio src="398396__caitlin-100__knife-scrape.mp3" id="tileremove"></audio>
<audio src="468414__atg65__power-failure.wav" id="coinfail"></audio>
<audio src="Lightless%20Dawn.mp3" loop id="bgm"></audio>
<div id="inventory">
    <ul>
    </ul>
</div>
<aside id="error">the knife doesn't work on that</aside>
<aside id="taken">knife</aside>
<script>
const unhidden = new Set();
const nowhidden = new Set();
let coin_move_count = 0;
let children_order = "";
let children_posns = {};
let children_posns_num = {};
let children_connections = [[0, 1], [0, 3], [1, 2], [1, 4], 
    [2, 5], [3, 6], [3, 4], [4, 5], [4, 7], [5, 8], [6, 7], [7, 8]];
let book_page = 1;
const handlers = {
    lines_intersect: (p1, p2, p3, p4) => {
        // https://stackoverflow.com/a/16725715/1418014
        function Turn(p1, p2, p3) {
            a = p1.x; b = p1.y; 
            c = p2.x; d = p2.y;
            e = p3.x; f = p3.y;
            A = (f - b) * (c - a);
            B = (d - b) * (e - a);
            return (A > B + Number.EPSILON) ? 1 : (A + Number.EPSILON < B) ? -1 : 0;
        }
        return (Turn(p1, p3, p4) != Turn(p2, p3, p4)) && (Turn(p1, p2, p3) != Turn(p1, p2, p4));
    },
    get_transformed_bbox: el => {
        let bb = el.getBBox();
        let t = ["ignore", "0", "0"];
        if (el.getAttribute("transform")) {
            t = el.getAttribute("transform").match(/translate\(([0-9.-]+)[ ,]([0-9.-]+)\)/);
        }
        bb.x += parseFloat(t[1]);
        bb.y += parseFloat(t[2]);
        return bb;
    },
    book_child_move: (el, event) => {
        // get dragged element and those it's paired with
        let thisend = el;
        let [c, level, group, end] = el.id.split("_");
        let otherend_id = c + "_" + level + "_" + group + "_" + (end == "1" ? "2" : "1");
        let otherend = document.getElementById(otherend_id);
        let rope = document.getElementById("rope_" + level + "_" + group);
        //console.log("Moving", thisend.id, "attached to", otherend_id, "by", rope.id);

        // calculate positions for everything so child can't be dragged off page
        let start = {x: event.pageX, y: event.pageY}
        let ctm = document.querySelector("svg").getScreenCTM();
        let bookPageBorders = document.querySelector("#page_right_2_page").getBBox();
        let elStart = handlers.get_transformed_bbox(el);
        let mindx = -(elStart.x - bookPageBorders.x);
        let mindy = -(elStart.y - bookPageBorders.y);
        let maxdx = (bookPageBorders.x + bookPageBorders.width - elStart.x - elStart.width);
        let maxdy = (bookPageBorders.y + bookPageBorders.height - elStart.y - elStart.height);
        let previousTransform = el.getAttribute("transform") || "";

        function mm(e) {
            let dx = Math.round(e.pageX - start.x);
            let dy = Math.round(e.pageY - start.y);
            // convert to svg matrix as per http://www.petercollingridge.co.uk/tutorials/svg/interactive/dragging/
            // (we don't need to subtract ctm.e etc because we're dealing with deltas, not absolutes)
            let nx = dx / ctm.a;
            let ny = dy / ctm.d;
            if (nx < mindx) { nx = mindx; }
            if (nx > maxdx) { nx = maxdx; }
            if (ny < mindy) { ny = mindy; }
            if (ny > maxdy) { ny = maxdy; }
            el.setAttribute("transform", previousTransform + " translate(" + nx + " " + ny + ")");
        }
        function mu(e) {
            document.removeEventListener("mousemove", mm);
            document.removeEventListener("mouseup", mu);

            // consolidate transforms on el
            let ts = el.getAttribute("transform").match(/[0-9.-]+/g).map(v => parseFloat(v));
            let nx, ny;
            if (ts.length == 2) {
                nx = Math.round(ts[0]);
                ny = Math.round(ts[1]);
            } else {
                nx = 0;
                ny = 0;
                for (let i=0; i<ts.length; i+=2) {
                    nx += Math.round(ts[i]);
                    ny += Math.round(ts[i+1]);
                }
            }
            el.setAttribute("transform", "translate(" + nx + " " + ny + ")");

            // move the rope
            let thisend_bb = handlers.get_transformed_bbox(thisend);
            let otherend_bb = handlers.get_transformed_bbox(otherend);
            let ropestartx = Math.round(thisend_bb.x + (thisend_bb.width / 2));
            let ropestarty = Math.round(thisend_bb.y + (thisend_bb.height / 2));
            let ropeendx = Math.round(otherend_bb.x + (otherend_bb.width / 2));
            let ropeendy = Math.round(otherend_bb.y + (otherend_bb.height / 2));
            rope.setAttribute("d", "M" + ropestartx + "," + ropestarty + " " + ropeendx + "," + ropeendy);

            // calculate crossings by seeing if the ropes intersects any of the four lines of the square of an adult
            let rope1 = document.getElementById("rope_3_1");
            let rope2 = document.getElementById("rope_3_2");
            let rnums1 = rope1.getAttribute("d").match(/[0-9.-]+/g).map(n => { return Math.round(parseFloat(n)); })
            let rbb1s = {x: rnums1[0], y: rnums1[1] };
            let rbb1e = {x: rnums1[2], y: rnums1[3] };
            let rnums2 = rope2.getAttribute("d").match(/[0-9.-]+/g).map(n => { return Math.round(parseFloat(n)); })
            let rbb2s = {x: rnums2[0], y: rnums2[1] };
            let rbb2e = {x: rnums2[2], y: rnums2[3] };
            let unfilled = 0;
            Array.from(document.querySelectorAll("#adult_3 path")).forEach(adult => {
                let bb = adult.getBBox();
                let bbt1 = {x: Math.round(bb.x), y: Math.round(bb.y)};
                let bbt2 = {x: Math.round(bb.x+bb.width), y: Math.round(bb.y)};
                let bbl1 = {x: Math.round(bb.x), y: Math.round(bb.y)};
                let bbl2 = {x: Math.round(bb.x), y: Math.round(bb.y+bb.height)};
                let bbr1 = {x: Math.round(bb.x+bb.width), y: Math.round(bb.y)};
                let bbr2 = {x: Math.round(bb.x+bb.width), y: Math.round(bb.y+bb.height)};
                let bbb1 = {x: Math.round(bb.x), y: Math.round(bb.y+bb.height)};
                let bbb2 = {x: Math.round(bb.x+bb.width), y: Math.round(bb.y+bb.height)};

                if (handlers.lines_intersect(rbb1s, rbb1e, bbt1, bbt2) ||
                    handlers.lines_intersect(rbb1s, rbb1e, bbl1, bbl2) ||
                    handlers.lines_intersect(rbb1s, rbb1e, bbb1, bbb2) ||
                    handlers.lines_intersect(rbb1s, rbb1e, bbr1, bbr2) ||
                    handlers.lines_intersect(rbb2s, rbb2e, bbt1, bbt2) ||
                    handlers.lines_intersect(rbb2s, rbb2e, bbl1, bbl2) ||
                    handlers.lines_intersect(rbb2s, rbb2e, bbb1, bbb2) ||
                    handlers.lines_intersect(rbb2s, rbb2e, bbr1, bbr2)) {
                    adult.style.fill = "black";
                } else {
                    var prevfill = adult.getAttribute("data-fill");
                    adult.style.fill = prevfill;
                    unfilled += 1;
                }
            });
            if (unfilled == 0) {
                document.getElementById("ignite").play();
                document.querySelector("#flames_3").style.visibility = "visible";
                setTimeout(() => { document.querySelector("#adult_3").style.visibility = "hidden"; }, 500);
                setTimeout(() => { document.querySelector("#flames_3").style.visibility = "hidden"; }, 1000);
            }
        }

        document.addEventListener("mousemove", mm);
        document.addEventListener("mouseup", mu);
        return;
    },
    book_right: el => {
        book_page += 1;
        handlers.book_set_page(book_page);
    },
    book_left: el => {
        if (book_page > 1) {
            book_page -= 1;
            handlers.book_set_page(book_page);
        }
    },
    book_init: el => {
        Array.from(document.querySelectorAll("#adult_3 path")).forEach(adult => {
            adult.setAttribute("data-fill", adult.style.fill);
        })
        handlers.book_set_page(book_page);
    },
    book_set_page: required_page => {
        Array.from(document.querySelectorAll('g[id^="page_"]')).forEach(page_el => {
            let pageno = parseInt(page_el.id.split("_")[1], 10);
            if (pageno == required_page) {
                page_el.style.visibility = "visible";
            } else {
                page_el.style.visibility = "hidden";
            }
        })
    },
    children_init: el => {
        console.log("children init!");
        children_order = "edrnhcli_";
        for (let i=0; i<children_order.length; i++) {
            let el;
            if (children_order[i] == "_") {
                el = document.getElementById("children_empty");
            } else {
                el = document.getElementById("children_" + children_order[i]);
            }
            children_posns_num[i] = el.getBBox();
            children_posns[children_order[i]] = el.getBBox();
        }
    },
    children_click: el => {
        let letter = el.id.split("_")[1];
        if (letter == "empty") return;
        let lpos = children_order.indexOf(letter);
        let empty = children_order.indexOf("_");
        let fromok = children_connections.filter(([a, b]) => a == lpos && b == empty);
        let took = children_connections.filter(([a, b]) => b == lpos && a == empty);
        let swapsies = null;
        if (fromok.length > 0 || took.length > 0) {
            // swap letter and empty
            let arr = Array.from(children_order);
            let tmp = arr[lpos];
            arr[lpos] = "_";
            arr[empty] = tmp;
            children_order = arr.join("");
            for (let i=0; i<children_order.length; i++) {
                let el;
                if (children_order[i] == "_") {
                    el = document.getElementById("children_empty");
                } else {
                    el = document.getElementById("children_" + children_order[i]);
                }
                let dx = children_posns_num[i].x - children_posns[children_order[i]].x;
                el.setAttribute("transform", "translate(" + dx + " 0)");
            }
        }
        if (children_order == "children_") {
            console.log("victory!");
        }
    },
    coin_click: el => {
        // if we don't have slots set up for coins, set them up
        if (!document.querySelector("[data-coin-slot]")) {
            document.getElementById("coin1").dataset.coinSlot = "4_3";
            document.getElementById("coin2").dataset.coinSlot = "3_3";
            document.getElementById("coin3").dataset.coinSlot = "3_4";
            document.getElementById("coin4").dataset.coinSlot = "2_2";
            document.getElementById("coin5").dataset.coinSlot = "2_3";
            document.getElementById("coin6").dataset.coinSlot = "2_4";
            coin_move_count = 0;
        }
        let existing = document.querySelector(".chosen-coin");
        if (existing) existing.classList.remove("chosen-coin");
        let existing_slots = document.querySelectorAll(".available-slot");
        if (existing_slots.length > 0) Array.from(existing_slots).map(es => {
            es.classList.remove("available-slot");
        });
        if (existing == el) { return; }
        el.classList.add("chosen-coin");
        // and calculate available slots
        let coins_in = Array.from(document.querySelectorAll("[data-coin-slot]")).map(cel => {
            return cel.dataset.coinSlot.split("_").map(v => parseInt(v, 10));
        })
        let two_coin_slots = {};
        let add = (x, y) => {
            if (!two_coin_slots[[y,x]]) two_coin_slots[[y,x]] = 0;
            two_coin_slots[[y,x]] += 1;
        }
        coins_in.forEach(([y, x]) => {
            if (el.dataset.coinSlot == y + "_" + x) return; // can't count us as part of the 2 coins!
            add(x-1, y); add(x+1, y);
            if (y%2 == 1) {
                // odd row
                add(x-1, y-1); add(x, y-1); add(x-1, y+1); add(x, y+1);
            } else {
                // even row
                add(x, y-1); add(x+1, y-1); add(x, y+1); add(x+1, y+1);
            }
        })
        // if we are a coin in the middle of a hexagon and there are only 1-coin-wide gaps
        // in the hexagon, then we can't move anywhere
        let our_hexagon = {1: "off", 2: "off", 3: "off", 4: "off", 5: "off", 6: "off"};
        let [our_y, our_x] = el.dataset.coinSlot.split("_").map(x => { return parseInt(x, 10); })
        let coins_in_text = coins_in.map(([y, x]) => y + "-" + x);
        let isCoin = (y, x) => {
            return coins_in_text.includes(y + "-" + x) ? "coin": "empty";
        }
        if (our_x > 1) { our_hexagon[3] = isCoin(our_y, our_x-1); }
        if ((our_x < 5 && our_y % 2 == 0) || (our_x < 6 && our_y % 2 == 1)) {
            our_hexagon[4] = isCoin(our_y, our_x+1);
        }
        if (our_y > 1 && (our_y % 2 == 0)) {
            our_hexagon[1] = isCoin(our_y-1, our_x);
            our_hexagon[2] = isCoin(our_y-1, our_x+1);
        }
        if (our_y > 1 && (our_y % 2 == 1)) {
            our_hexagon[1] = isCoin(our_y-1, our_x-1);
            our_hexagon[2] = isCoin(our_y-1, our_x);
        }
        if (our_y < 5 && (our_y % 2 == 0)) {
            our_hexagon[5] = isCoin(our_y+1, our_x);
            our_hexagon[6] = isCoin(our_y+1, our_x+1);
        }
        if (our_y < 5 && (our_y % 2 == 1)) {
            our_hexagon[5] = isCoin(our_y+1, our_x-1);
            our_hexagon[6] = isCoin(our_y+1, our_x);
        }
        if ((our_hexagon[1] == "empty" && our_hexagon[2] == "empty") ||
            (our_hexagon[1] == "empty" && our_hexagon[3] == "empty") ||
            (our_hexagon[2] == "empty" && our_hexagon[4] == "empty") ||
            (our_hexagon[3] == "empty" && our_hexagon[5] == "empty") ||
            (our_hexagon[4] == "empty" && our_hexagon[5] == "empty") ||
            (our_hexagon[5] == "empty" && our_hexagon[6] == "empty")) {
            // there is a two-coin gap, so we're OK; continue as planned
        } else {
            // no two-coin gap, so wipe two_coin_slots because this coin is not moveable
            two_coin_slots = {};
        }

        for (let k in two_coin_slots) {
            if (two_coin_slots[k] >= 2) {
                let slot = document.getElementById("coin_slot_" + k.replace(",", "_"));
                if (slot) {
                    slot.classList.add("available-slot");
                }
            }
        }
    },
    coin_slot_click: el => {
        if (coin_move_count == 4) return;
        if (!el.classList.contains("available-slot")) return;
        let cc = document.querySelector(".chosen-coin");
        if (!cc) return;
        let fromSlot = document.getElementById("coin_slot_" + cc.dataset.coinSlot);
        let fromBB = fromSlot.getBBox();
        let toBB = el.getBBox();
        let xdiff = toBB.x - fromBB.x;
        let ydiff = toBB.y - fromBB.y;
        let trans = cc.getAttribute("transform");
        let parts = trans.replace("matrix(", "").replace(")", "").split(",");
        parts[4] = (parseFloat(parts[4]) + xdiff).toString();
        parts[5] = (parseFloat(parts[5]) + ydiff).toString();
        cc.setAttribute("transform", "matrix(" + parts.join(",") + ")");
        cc.classList.remove("chosen-coin");
        cc.dataset.coinSlot = el.id.replace("coin_slot_", "");
        let existing_slots = document.querySelectorAll(".available-slot");
        if (existing_slots.length > 0) Array.from(existing_slots).map(es => {
            es.classList.remove("available-slot");
        });
        coin_move_count += 1;
        document.getElementById("coin_move_" + coin_move_count).style.display = "none";
        if (coin_move_count == 4) {
            let coins_in = Array.from(document.querySelectorAll("[data-coin-slot]")).map(cel => {
                return cel.dataset.coinSlot.split("_").map(v => parseInt(v, 10));
            })
            let my = Math.min.apply(null, coins_in.map(a => a[0]));
            let mx = Math.min.apply(null, coins_in.map(a => a[1]));
            coins_in = coins_in.map(([y, x]) => [y-my, x-mx]);
            coins_in.sort((a, b) => {
                if (a[0] == b[0]) return a[1] - b[1];
                return a[0] - b[0];
            });
            let result = coins_in.map(([y, x]) => y + "" + x).join("");
            if (result == "010210122122" || result == "000110122021") {
                console.log("ok!");
                return;
            } else {
                console.log(result);
            }

            document.getElementById("coinfail").play();
            setTimeout(() => {
                coin_move_count = 0;
                load("coins");
            }, 1000);
        }
    },
    drawer_slide: el => {
        if (!el.dataset.open) {
            el.style.transform = "translateY(16%)";
            el.dataset.open = "yes";
        } else {
            el.style.transform = "";
            el.dataset.open = "";
        }
        document.getElementById("drawer").play();
    },
    start_music: el => {
        document.getElementById("bgm").play();
    },
    take: async el => {
        /* remember to remove the desc from the SVGs for individual items, or they're takeable
           when they're in inventory */
        taken.push({scene: currentRoom, obj: el.getAttribute("id")});
        el.remove();
        document.getElementById("collect").play();
        let li = document.createElement("li");
        let response = await fetch(el.id + ".svg");
        li.innerHTML = await response.text();
        li.dataset.using = "no";
        li.dataset.item = el.id;
        li.onclick = function() {
            if (li.dataset.using == "no") {
                let existing = document.querySelector('li[data-using="yes"]');
                if (existing) { existing.dataset.using = "no"; }
                let invsvg = li.querySelector("svg");
                let crs = invsvg.cloneNode(true);
                let bb = invsvg.getBoundingClientRect();
                crs.setAttribute("width", bb.width);
                crs.setAttribute("height", bb.width);
                [_, _, vbw, vbh] = crs.getAttribute('viewBox').split(" ");
                let pointer = document.createElementNS("http://www.w3.org/2000/svg", "path");
                pointer.setAttribute("d", "M0,0 L" + (vbw / 8) + ",0 L0," + (vbw / 8) + "Z");
                pointer.setAttribute("fill", "red")
                crs.appendChild(pointer);
                let dataurl = "data:image/svg+xml;base64," + btoa(crs.outerHTML);
                document.body.style.cursor = "url(" + dataurl + "), auto";
                li.dataset.using = "yes";
            } else {
                document.body.style.cursor = "auto";
                li.dataset.using = "no";
            }
        }
        document.querySelector("#inventory ul").appendChild(li);
        show_taken(el.getAttribute("id"));
    },
    use: (nail, hammer) => { // these are IDs, not elements
        console.log("using", hammer, "on", nail);
        if (nail == "candle" && hammer == "matches") {
            document.getElementById("flame").style.display = "block";
            document.getElementById("glow").style.display = "block";
            document.getElementById("secretmessage").style.display = "block";
            unhidden.add("flame");
            unhidden.add("glow");
            unhidden.add("secretmessage");
            document.getElementById("ignite").play();
        } else if (nail == "tiles" && hammer == "knife") {
            document.getElementById("tileholes").style.display = "block";
            unhidden.add("tileholes");
            document.getElementById("tiles").style.display = "none";
            nowhidden.add("tiles");
            document.getElementById("tileremove").play();
        } else {
            show_error("The " + hammer + " doesn't work on that");
        }
    }
}
let currentRoom;
const taken = [];
const buttons = new Set(["down", "up", "left", "right"]);
function show_error(msg) {
    let aside = document.querySelector("aside#error");
    aside.textContent = msg;
    aside.style.opacity = 1;
    setTimeout(() => { aside.style.opacity = 0; }, 1500);
}
function show_taken(msg) {
    let aside = document.querySelector("aside#taken");
    aside.textContent = msg;
    aside.style.opacity = 1;
    setTimeout(() => { aside.style.opacity = 0; }, 1500);
}
function hookup() {
    let buttons_found = new Set();
    let aside = document.querySelector("aside");
    Array.from(document.querySelectorAll("svg desc")).forEach(el => {
        let p = el.parentNode;
        let clickrect;
        el.textContent.split("\n").forEach(line => {
            let parts = line.trim().split(":");
            if (parts.length == 2) {
                if (parts[0] == "click" || parts[0] == "use" || parts[0] == "mousedown") {
                    let fn;
                    if (parts[0] == "use") {
                        fn = (e) => {
                            // note: you must define use handlers before click handlers in the description!
                            // otherwise the click handler will be defined before the use handler, and so
                            // the use handler's stopImmediatePropagation will be useless
                            let existing = document.querySelector('li[data-using="yes"]');
                            if (existing) {
                                if (parts[1] == existing.dataset.item) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    e.stopImmediatePropagation();
                                    handlers.use(p.id, parts[1]);
                                } else {
                                    show_error("The " + existing.dataset.item + " doesn't work on that");
                                }
                            }
                        }
                    } else if (handlers[parts[1]]) {
                        fn = (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            handlers[parts[1]](p, e);
                        }
                    } else {
                        fn = () => {
                            load(parts[1]);
                        }
                    }
                    let vbbg = p.getBBox();
                    let rect;
                    if (clickrect) {
                        rect = clickrect;
                    } else {
                        rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                        rect.setAttribute("x", vbbg.x)
                        rect.setAttribute("y", vbbg.y)
                        rect.setAttribute("width", vbbg.width)
                        rect.setAttribute("height", vbbg.height)
                        rect.setAttribute("fill", "transparent")
                        rect.setAttribute("data-clickrect", "clickrect");
                        rect.dataset.clickable = "clickable";
                        if (p.nodeName != "g") {
                            // putting the clickrect inside another element is likely to
                            // not work because the other element will eat all our clicks
                            // so put it in the parent of the parentNode, and make sure it's
                            // at the end, so definitely after the actual element and therefore
                            // on top of it
                            p.parentNode.appendChild(rect);
                        } else {
                            p.insertBefore(rect, p.firstChild);
                        }
                        clickrect = rect;
                    }
                    if (parts[0] == "mousedown") {
                        rect.addEventListener("mousedown", fn, false);
                    } else {
                        rect.addEventListener("click", fn, false);
                    }
                } else if (buttons.has(parts[0])) {
                    buttons_found.add(parts[0]);
                    document.getElementById(parts[0]).dataset.goto = parts[1];
                } else if (parts[0] == "init") {
                    handlers[parts[1]](p);
                }
            } else if (parts.length == 1) {
                if (parts[0] == "takeable") {
                    fn = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        handlers.take(p);
                    }
                    let vbbg = p.getBBox();
                    let rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    rect.setAttribute("x", vbbg.x)
                    rect.setAttribute("y", vbbg.y)
                    rect.setAttribute("width", vbbg.width)
                    rect.setAttribute("height", vbbg.height)
                    rect.setAttribute("fill", "transparent")
                    p.insertBefore(rect, p.firstChild);
                    rect.onclick = fn;
                    rect.dataset.clickable = "clickable";
                } else if (parts[0] == "hidden" && !unhidden.has(p.id)) {
                    // note: if an element is hidden and has click or use handlers,
                    // you must define hidden AFTER other stuff, otherwise we hide it
                    // first and then can't create the bbox for it to make a clickrect
                    p.style.visibility = "hidden";
                }
            }
        })
    })
    buttons.forEach(bname => {
        if (buttons_found.has(bname)) {
            document.getElementById(bname).style.display = "block";
        } else {
            document.getElementById(bname).style.display = "none";
        }
    })
    // and make all not-explicitly-clickable leaf elements unclickable
    Array.from(document.querySelectorAll("svg *")).forEach(el => {
        if (!el.dataset.clickable && el.childNodes.length === 0) {
            el.style.pointerEvents = "none";
        }
    })
    // and remove all already-taken items that aren't in inventory
    taken.filter(item => item.scene == currentRoom).map(
        item => { 
            let obj = document.getElementById(item.obj);
            if (!obj.closest("#inventory")) {
                obj.remove();
            }
        })
    // and remove all now hidden items
    Array.from(nowhidden).map(
        item => { 
            let obj = document.getElementById(item);
            if (obj) obj.remove();
        })
    // and show main (it was made invisible so that we don't see hidden stuff briefly appear)
    document.querySelector("main").style.opacity = "1";
}
function resize() {
    // size the svg
    let svg = document.querySelector("main > svg");
    let war = window.innerWidth / window.innerHeight;
    let sar = 800 / 600;
    let t, l, w, h;
    if (war > sar) {
        h = window.innerHeight;
        w = h * sar;
        t = 0;
        l = (window.innerWidth - w) / 2;
    } else {
        w = window.innerWidth;
        h = w / sar;
        l = 0;
        t = (window.innerHeight - h) / 2;
    }
    svg.style.height = h + "px";
    svg.style.width = w + "px";
    svg.style.top = t + "px";
    svg.style.left = l + "px";
    // move inventory
    let inv = document.querySelector("#inventory");
    let iw = w / 8;
    inv.style.width = iw + "px";
    inv.style.left = (l + w - iw) + "px";
    inv.style.top = t + "px";
    inv.style.height = h + "px";
    // and move the buttons
    let up = document.querySelector("#up");
    let right = document.querySelector("#right");
    let down = document.querySelector("#down");
    let left = document.querySelector("#left");
    let bh = h / 20; let bw = w / 20;
    up.style.top = t + "px"; up.style.left = l + "px";
    up.style.width = (w - iw) + "px"; up.style.height = bh + "px";
    left.style.top = t + "px"; left.style.left = l + "px";
    left.style.width = bw + "px"; left.style.height = h + "px";
    down.style.top = (t + h - bh) + "px"; down.style.left = l + "px";
    down.style.width = (w - iw) + "px"; down.style.height = bh + "px";
    right.style.top = t + "px"; right.style.left = (l + w - bw - iw) + "px";
    right.style.width = bw + "px"; right.style.height = h + "px";
    // and the error
    let error = document.querySelector("aside#error");
    error.style.top = (t + bh + 20) + "px";
    error.style.left = (l + bw + 20) + "px";
    // and the taken
    let taken = document.querySelector("aside#taken");
    taken.style.top = (t + bh + 20) + "px";
    taken.style.right = (((window.innerWidth - w) / 2) + iw + 20) + "px";
}
async function load(r) {
    Array.from(document.querySelectorAll("aside div")).forEach(d => { d.remove() });
    let response = await fetch(r + ".svg");
    document.querySelector("main").style.opacity = "0";
    setTimeout(async () => {
        document.querySelector("main").innerHTML = await response.text();
        currentRoom = r;
        resize();
        setTimeout(hookup, 0);
    }, 100);
}
buttons.forEach(bname => {
    let b = document.getElementById(bname);
    b.onclick = () => {
        load(b.dataset.goto); 
    }
});
load("title");
window.onresize = resize;
</script>
</body>
</html>